name: CD

on:
  workflow_dispatch:
    inputs:
      aws_region:
        description: "AWS region (fallback: repo variable AWS_REGION)"
        required: false
        type: string
      aws_account_id:
        description: "AWS account id (fallback: repo variable AWS_ACCOUNT_ID)"
        required: false
        type: string
      eks_cluster_name:
        description: "EKS cluster name (fallback: repo variable EKS_CLUSTER_NAME)"
        required: false
        type: string
      dd_site:
        description: "Datadog site (fallback: repo variable DD_SITE)"
        required: false
        type: string
        default: "datadoghq.com"
      ddb_table:
        description: "DynamoDB table name (fallback: repo variable DDB_TABLE)"
        required: false
        type: string
        default: "orders"
  push:
    branches: [ main ]
    paths:
      - 'app/**'
      - 'k8s/**'

env:
  AWS_REGION: ${{ inputs.aws_region || vars.AWS_REGION }}
  AWS_ACCOUNT_ID: ${{ inputs.aws_account_id || vars.AWS_ACCOUNT_ID }}
  EKS_CLUSTER_NAME: ${{ inputs.eks_cluster_name || vars.EKS_CLUSTER_NAME }}
  ECR_REPO_BACKEND: ${{ vars.ECR_REPO_BACKEND }}
  ECR_REPO_FRONTEND: ${{ vars.ECR_REPO_FRONTEND }}
  DD_SITE: ${{ inputs.dd_site || vars.DD_SITE || 'datadoghq.com' }}
  DDB_TABLE: ${{ inputs.ddb_table || vars.DDB_TABLE || 'orders' }}

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@v4

      - name: Validate required variables
        run: |
          echo "Using variables:" \
            && echo "AWS_REGION=$AWS_REGION" \
            && echo "AWS_ACCOUNT_ID=$AWS_ACCOUNT_ID" \
            && echo "EKS_CLUSTER_NAME=$EKS_CLUSTER_NAME" \
            && echo "ECR_REPO_BACKEND=${ECR_REPO_BACKEND:-unset}" \
            && echo "ECR_REPO_FRONTEND=${ECR_REPO_FRONTEND:-unset}" \
            && echo "DD_SITE=$DD_SITE" \
            && echo "DDB_TABLE=$DDB_TABLE"
          missing=0
          [ -n "$AWS_REGION" ] || { echo "ERROR: AWS_REGION não definido (defina em repo variables ou passe em workflow_dispatch)."; missing=1; }
          [ -n "$EKS_CLUSTER_NAME" ] || { echo "ERROR: EKS_CLUSTER_NAME não definido."; missing=1; }
          [ -n "${{ vars.OIDC_IAM_ROLE_ARN }}" ] || { echo "ERROR: OIDC_IAM_ROLE_ARN não definido em repo variables."; missing=1; }
          [ -n "$ECR_REPO_BACKEND" ] || { echo "WARN: ECR_REPO_BACKEND não definido; build poderá falhar."; }
          [ -n "$ECR_REPO_FRONTEND" ] || { echo "WARN: ECR_REPO_FRONTEND não definido; build poderá falhar."; }
          if [ "$missing" -ne 0 ]; then exit 1; fi

      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.OIDC_IAM_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to ECR
        id: ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set image tags
        id: vars
        run: |
          echo "TAG=${GITHUB_SHA::7}" >> $GITHUB_OUTPUT

      - name: Build backend image
        uses: docker/build-push-action@v6
        with:
          context: app/backend
          push: true
          tags: |
            ${{ steps.ecr.outputs.registry }}/${{ env.ECR_REPO_BACKEND }}:${{ steps.vars.outputs.TAG }}
            ${{ steps.ecr.outputs.registry }}/${{ env.ECR_REPO_BACKEND }}:latest

      - name: Build frontend image
        uses: docker/build-push-action@v6
        with:
          context: app/frontend
          push: true
          build-args: |
            VITE_BACKEND_URL=/api
          tags: |
            ${{ steps.ecr.outputs.registry }}/${{ env.ECR_REPO_FRONTEND }}:${{ steps.vars.outputs.TAG }}
            ${{ steps.ecr.outputs.registry }}/${{ env.ECR_REPO_FRONTEND }}:latest

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --region $AWS_REGION --name $EKS_CLUSTER_NAME

      - name: Prepare namespace and config
        run: |
          kubectl apply -f k8s/namespace.yaml
          # ConfigMap with environment
          if kubectl -n case get cm env-config >/dev/null 2>&1; then
            echo "env-config exists"
          else
            sed -e "s/<AWS_REGION>/${AWS_REGION}/g" \
                -e "s/orders/${DDB_TABLE}/g" \
                -e "s/datadoghq.com/${DD_SITE}/g" k8s/env-config.yaml | kubectl apply -f -
          fi
          # Datadog API key secret
          if [ -n "${{ secrets.DD_API_KEY }}" ]; then
            sed -e "s/<DD_API_KEY>/${{ secrets.DD_API_KEY }}/g" k8s/datadog-secret.yaml | kubectl apply -f -
          fi
          # Backend SA with IRSA annotation
          if [ -n "${{ secrets.BACKEND_IRSA_ROLE_ARN }}" ]; then
            sed -e "s#<BACKEND_IRSA_ROLE_ARN>#${{ secrets.BACKEND_IRSA_ROLE_ARN }}#g" k8s/backend-serviceaccount.yaml | kubectl apply -f -
          fi

      - name: Apply manifests
        run: |
          sed -e "s~<AWS_ACCOUNT_ID>~${AWS_ACCOUNT_ID}~g" -e "s~<AWS_REGION>~${AWS_REGION}~g" k8s/backend-deployment.yaml | kubectl apply -f -
          sed -e "s~<AWS_ACCOUNT_ID>~${AWS_ACCOUNT_ID}~g" -e "s~<AWS_REGION>~${AWS_REGION}~g" k8s/frontend-deployment.yaml | kubectl apply -f -
          kubectl apply -f k8s/ingress.yaml

      - name: Set backend image to specific tag
        run: |
          kubectl set image deployment/backend -n case backend=${{ steps.ecr.outputs.registry }}/${{ env.ECR_REPO_BACKEND }}:${{ steps.vars.outputs.TAG }}

      - name: Set frontend image to specific tag
        run: |
          kubectl set image deployment/frontend -n case frontend=${{ steps.ecr.outputs.registry }}/${{ env.ECR_REPO_FRONTEND }}:${{ steps.vars.outputs.TAG }}

      - name: Install LitmusChaos (operator) if missing
        run: |
          kubectl get ns litmus >/dev/null 2>&1 || kubectl create ns litmus
          kubectl apply -f https://litmuschaos.github.io/litmus/litmus-operator-v3.yaml

      - name: Install pod-delete experiment from LitmusHub
        run: |
          kubectl -n litmus apply -f "https://hub.litmuschaos.io/api/chaos/3.6.0?file=charts/generic/pod-delete/experiment.yaml"

      - name: Configure Litmus RBAC in target namespace
        run: |
          kubectl apply -f k8s/litmus/litmus-rbac.yaml

      - name: Run backend pod-delete ChaosEngine
        run: |
          kubectl apply -f k8s/litmus/backend-pod-delete-engine.yaml
          echo "Waiting for ChaosResult verdict..."
          for i in {1..60}; do
            verdict=$(kubectl -n case get chaosresult backend-pod-delete -o jsonpath='{.status.experimentStatus.verdict}' 2>/dev/null || echo "")
            if [ "$verdict" = "Pass" ] || [ "$verdict" = "Fail" ]; then
              echo "Chaos verdict: $verdict"; break; fi; sleep 10; done
          kubectl -n case rollout status deploy/backend-green --timeout=120s || true
          kubectl -n case get pods -l app=backend -o wide || true
          if [ "$verdict" = "Fail" ] || [ -z "$verdict" ]; then
            echo "Chaos test did not pass"; exit 1; fi

      - name: Optional Prometheus install (set ENABLE_PROMETHEUS=true)
        if: ${{ vars.ENABLE_PROMETHEUS == 'true' }}
        run: |
          helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
          helm repo update
          helm upgrade --install kps prometheus-community/kube-prometheus-stack -n monitoring --create-namespace

      - name: Apply Datadog dashboards (optional)
        env:
          DD_API_KEY: ${{ secrets.DD_API_KEY }}
          DD_APP_KEY: ${{ secrets.DD_APP_KEY }}
          DD_SITE: ${{ vars.DD_SITE || 'datadoghq.com' }}
        run: |
          if [ -z "${DD_API_KEY}" ] || [ -z "${DD_APP_KEY}" ]; then
            echo "Skipping Datadog dashboards apply: missing DD_API_KEY or DD_APP_KEY";
            exit 0;
          fi
          sudo apt-get update && sudo apt-get install -y jq
          bash scripts/datadog-apply-dashboards.sh

      - name: Apply Datadog monitors (optional)
        env:
          DD_API_KEY: ${{ secrets.DD_API_KEY }}
          DD_APP_KEY: ${{ secrets.DD_APP_KEY }}
          DD_SITE: ${{ vars.DD_SITE || 'datadoghq.com' }}
        run: |
          if [ -z "${DD_API_KEY}" ] || [ -z "${DD_APP_KEY}" ]; then
            echo "Skipping Datadog monitors apply: missing DD_API_KEY or DD_APP_KEY";
            exit 0;
          fi
          sudo apt-get update && sudo apt-get install -y jq
          bash scripts/datadog-apply-monitors.sh
